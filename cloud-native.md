# Cloud Native

## What is Cloud Native

Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.  

These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.  

The Cloud Native Computing Foundation seeks to drive adoption of this paradigm by fostering and sustaining an ecosystem of open source, vendor-neutral projects. We democratize state-of-the-art patterns to make these innovations accessible for everyone.

## The Twelve-Factor Application

1. Code Base
    
    A single code base for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).

2. Dependencies	

    Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.

3. Configurations

    Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code. The same deployment can propagate across environments with the correct configuration applied.

4. Backing Services	

    Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL. Doing so decouples the resource from the application, enabling it to be interchangeable.

5. Build, Release, Run

    Each release must enforce a strict separation across the build, release, and run stages. Each should be tagged with a unique ID and support the ability to roll back. Modern CI/CD systems help fulfill this principle.

6. Processes

    Each microservice should execute in its own process, isolated from other running services. Externalize required state to a backing service such as a distributed cache or data store.

7. Port Binding

    Each microservice should be self-contained with its interfaces and functionality exposed on its own port. Doing so provides isolation from other microservices.

8. Concurrency

    When capacity needs to increase, scale out services horizontally across multiple identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available. Develop the application to be concurrent making scaling out in cloud environments seamless.

9. Disposability

    Service instances should be disposable. Favor fast startup to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement.

10. Dev/Prod Parity	

    Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts. Here, the adoption of containers can greatly contribute by promoting the same execution environment.

11. Logging	

    Treat logs generated by microservices as event streams. Process them with an event aggregator. Propagate log data to data-mining/log management tools like Azure Monitor or Splunk and eventually to long-term archival.

12. Admin Processes	

    Run administrative/management tasks, such as data cleanup or computing analytics, as one-off processes. Use independent tools to invoke these tasks from the production environment, but separately from the application.

In the book, Beyond the Twelve-Factor App, author Kevin Hoffman details each of the original 12 factors (written in 2011). Additionally, he discusses three extra factors that reflect today's modern cloud application design.

13. API First

    Make everything a service. Assume your code will be consumed by a front-end client, gateway, or another service.

14. Telemetry	

    On a workstation, you have deep visibility into your application and its behavior. In the cloud, you don't. Make sure your design includes the collection of monitoring, domain-specific, and health/system data.

15. Authentication/ Authorization	

    Implement identity from the start. Consider RBAC (role-based access control) features available in public clouds.

## Principles

### Scalable
We'll start with scalable. Scalability is one of the primary motivators for moving to the cloud. With microservices, you can scale different functional areas of your application at different rates, depending on what they need.

Once you are thinking in terms of microservices, the next step is to think about placing those microservices into containers. Docker popularized the idea of packaging software into immutable bundles and running them in isolation, without requiring a full operating system per service. This difference between containers vs. virtual machines allows you to run many more containers on the same underlying hardware than you could with VMs.

#### What makes a microservice cloud native?
Cloud native microservices follow certain design principles. The most important is that they are designed as stateless immutable infrastructure. This means two things:

- The container hosting your microservice doesn’t store any data.
- Once you launch a container, you do not modify it.

This leads to the question: how do you make updates? The answer is that in a cloud native architecture, whenever you want to change a cloud native microservice, you launch a new instance with the updates and turn off the old instance. This is in contrast to the older approach of making updates in place on a single server. The practice is somewhat heartlessly referred to as the difference between pets and livestock.

#### Crafting cloud native architecture
Once you’ve created these immutable instances, you are well on your way to building a cloud native architecture. Your teams can now take advantage of services from cloud providers to increase the scalability of your systems. When no one server instance is special, you can use services from the cloud provider to auto-scale, or configure your environment to automatically add and remove virtual server instances as the load on your system changes.

As your teams get more comfortable, they will find themselves exploring more ways to focus on your company’s core competencies. For example, consider customer identity. Rather than managing this information yourself, cloud providers (as well as third-party companies) have identity management solutions using standards like OAuth2 and OIDC. Similar solutions exist for other enabling technologies, like machine learning or batch processing. Cloud native architectures not only scale your software, they also scale your development team’s capabilities by letting you focus on what you do best. 

### Resilient
Another key part of a cloud-native architecture is that it is resilient. What does this mean? As Matthew Titmus explains in "Cloud Native Go":

> Resilience (roughly synonymous with fault tolerance) is a measure of how well a system withstands and recovers from errors and faults. A system can be considered resilient if it can continue operating correctly—possibly at a reduced level—rather than failing completely when some part of the system fails.

Just as you need to modify your software to make it more scalable, you will need to make changes to make your software more resilient. Like scalability, there are tremendous payoffs when you make your systems more resilient, because they stay running and teams aren't scrambling to fix problems.

Cloud providers provide some tools to help with resiliency, too. There's overlap with scalability. If a microservice crashes due to a rare error, an autoscaler can launch a new copy. Autoscaling also allows your systems to absorb load rather than shed it. Other cloud provider tools help, too. When you use databases or data processing platforms managed by your cloud provider, you can quickly increase their resources if they need more CPU or storage.

Cloud providers also allow you to increase resiliency by spreading your services across regions.  A region is a geographical area with one or more data centers, such as the East Coast of the United States or São Paulo, Brazil. Within a region, each data center is assigned to one of several availability zones. To ensure that a failure in a data center doesn't cause an outage for your company, it is recommended that you launch services across multiple availability zones. Following the principles of statelessness and treating your servers as livestock means that your system will continue to function even if a single availability zone or region goes down. And if you use a data store from a cloud provider, they can automatically replicate data across availability zones and even regions.

### Manageable
Another key aspect of cloud-native computing is that it is manageable. All of these components can be viewed from a UI or have their status queried via an API. Having an API to discover and modify the state of your environment means that you can write tools to this work in a repeatable way. It also means that you can describe the environment in a script and run that script to deploy, update, or delete your components. AWS provides a tool called CloudFormation to do this, but many companies use Terraform, a cross-platform tool from Hashicorp, to manage their environment.

### Observable
Closely related to manageability is observability. Once you have multiple components running together, you want to understand what they are doing. You also want to know when something goes wrong. Even if your developers design for resiliency, your operations people still need to know about problems as soon as they happen to prevent the situation from getting worse. Amazon provides a service called CloudWatch to provide this functionality. CloudWatch collects data from AWS on how your application is running and metrics on how your applications are performing. Furthermore, your application's logs can be sent to Cloudwatch as well, so that you see the information from your code alongside the information captured by AWS.

In addition to observing your systems as they are running, it is also helpful to observe the API calls to your cloud provider that configure your system. These calls can tell you if systems are configured correctly, and can possibly detect malicious activity. AWS uses CloudTrail to report on API calls, Google has Cloud Audit Logs, while Azure's Monitor service tracks API calls as well as application performance.

### Automated
Finally, you need to rely on automation to ensure consistency in your cloud environment. Automation ties all of our cloud native principles together. Scalability is possible because we automate the deployment of immutable infrastructure. Systems are more resilient when we can automatically restart them on failure or when they automatically fail over to a backup system when they detect a problem in a dependency. Automated management tools allow you to keep track of what is running, and automation allows you to find out when your observable systems are misbehaving.
 
There are more ways that automation enables cloud native software. When you are releasing new versions, you don't want to have a system administrator install software by hand. Instead, you should take advantage of deployment pipelines that automate the build, test, and deployment process, like AWS’ CodePipeline, Google’s Cloud Build, or Azure's Pipelines. Automation ensures consistency and allows you to do things like roll out a new version of your software to a limited subset of your servers to see if it functions correctly.

In addition to improving the deployment experience for cloud-native software, automation also helps with the management of your environment. You need to make sure that all of the components of your software are configured correctly. This includes things like validating access permissions, ensuring that only customer-facing applications are exposed to the public internet, or making sure that all of your cloud resources are properly tagged with information to identify which team is the owner. You might also want to implement cloud cost optimization measures like turning off components in a QA environment when the engineers are sleeping and turning them back on again when they return to work.

## Benefits of Micro Service

### Characteristics

- Independently deployable - e.g., the front-end service can be deployed independently of the authentication service
- Highly observable - through logging, monitoring, tracing, etc, one can determine what the service is doing
- Loosely coupled - the service can perform its work without being overly dependent on how any other service is defined or implemented
- Decentralized - spread across many different “systems,” potentially across many different geographies
- Highly testable - developed from the beginning to be testable through automated test frameworks with high coverage rates
- Highly maintainable - well-structured, well-commented, easy to understand, easy to change, easy and fast to build, etc (small size helps with all of this)
- Fungible - easily replaced or reimplemented as requirements dictate
- Focused and specialized - similar to the Unix philosophy of “do one thing well”
Contractual - having regimented, well-defined interfaces with deliberate life cycles

### Benefits

1. Asymmetric Service Scaling

    One of several microservices advantages is that it is well-suited for massive scalability, as each microservice can scale independently. To achieve this goal, the service must be “independently deployable” and “decentralized” to meet demand. A “highly observable” service provides metrics which can be used to drive scaling operations.

2. Zero Downtime

    A direct follow-on from above, another benefit to microservices being “independently deployable” is zero downtime. A new version of a microservice can be incrementally rolled out, coexist with the old version, and eventually replace the old version.

3. Intelligent Deployment

    Using a service mesh-enabled Kubernetes platform, canary testing of coexisting versions of a microservice is easily achieved. Weightings, HTTP headers, or a number of other criteria can be used to shape or route traffic to slowly ramp up work to the new service in a controlled manner. 

4. Innovation Through Polyglot Programming

    "Loosely coupled" and “contractual” microservices provide the ideal environment for a polyglot programming model as teams can choose whichever language they prefer in order to produce the new feature quickly.

5. Refactoring, Rewriting, and Decomposing

    In the aforementioned polyglot programming model, a legacy, monolithic application can be decomposed into microservices over time. This incremental progression enables the other benefits of microservices while the legacy application is still being phased out. 

6. Separation of Logic and Responsibilities

    Very large projects are usually very complicated. No one team can know everything. Furthermore, for compliance or security purposes, teams may be purposely cordoned off from other areas of the project. A “loosely coupled,” “independently deployable,” “specialized,” and “contractual” microservice allows teams to focus their efforts on the business logic in their area of expertise or access.

7. Error Handling and Resiliency Design Patterns

    It is a fact of life that failure is unpreventable, so if you fail, fail small. The circuit breaker pattern is often used to prevent systemic failure due to a root cause in an isolated component. As microservices communicate with each other to perform work, one way to introduce the circuit breaker pattern is to insert control points between the microservices. As an example, a service mesh-enabled Kubernetes platform provides built-in mechanisms to introduce circuit breakers and leverage the benefits of microservices.

## References:
- https://github.com/cncf/toc/blob/main/DEFINITION.md
- https://www.capitalone.com/software/blog/what-is-cloud-native/
- https://www.capitalone.com/tech/software-engineering/microservices-benefits/
- https://www.oreilly.com/library/view/cloud-native-go/9781492076322/
- https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition
- https://12factor.net
